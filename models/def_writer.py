#def_writer.py
import datetime

MICRONS_PER_GRID = 1000  # 1 grid unit → 1 000 µm (adjust to your tech)

def write_def(layout_xy,
              grid_w, grid_h,
              macro_names=None,
              design_name="GA_LAYOUT",
              units=MICRONS_PER_GRID,
              outfile="best_layout.def"):
    """
    Convert a (N,2) int array of grid coords to a placement-only DEF.
    Only COMPONENTS and DIEAREA sections are emitted.

    layout_xy   : ndarray | list  -> [[x0,y0],[x1,y1], …]
    grid_w/h    : grid limits (same as GRID_WIDTH / GRID_HEIGHT)
    macro_names : optional list of cell master names; falls back to "MACRO0"…
    """
    n = len(layout_xy)
    if macro_names is None:
        macro_names = [f"MACRO{i}" for i in range(n)]

    assert len(macro_names) == n, "macro_names length must match layout"

    with open(outfile, "w") as f:
        ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        f.write(f";  Auto-generated by GA on {ts}\n")
        f.write("VERSION 5.8 ;\n")
        f.write("DIVIDERCHAR \"/\" ;\n")
        f.write("BUSBITCHARS \"[]\" ;\n")
        f.write(f"DESIGN {design_name} ;\n")
        f.write(f"UNITS DISTANCE MICRONS {units} ;\n\n")

        # Simple rectangular die: lower-left (0,0) to upper-right
        die_x = grid_w * units
        die_y = grid_h * units
        f.write(f"DIEAREA ( 0 0 ) ( {die_x} {die_y} ) ;\n\n")

        f.write(f"COMPONENTS {n} ;\n")
        for i, (xy, master) in enumerate(zip(layout_xy, macro_names)):
            x, y = (int(v) * units for v in xy)
            inst = f"U{i}"
            f.write(f"  - {inst} {master} + PLACED ( {x} {y} ) N ;\n")
        f.write("END COMPONENTS\n\n")
        f.write("END DESIGN\n")
    print(f"DEF written → {outfile}")
